# from https://github.com/dreamsxin/modpagespeed/blob/master/src/install/debug_conf.vcl
# also add also purge + restart support with https://www.varnish-software.com/book/3/Saving_a_request.html

import std;

# Block 1: Define upstream server's host and port.
backend default {
  # Location of PageSpeed server.
  .host = "127.0.0.1";
  .port = "8080";
}

# Block 2: Define a key based on the User-Agent which can be used for hashing.
# Also set the PS-CapabilityList header for PageSpeed server to respect.
sub generate_user_agent_based_key {
    # Define placeholder PS-CapabilityList header values for large and small
    # screens with no UA dependent optimizations. Note that these placeholder
    # values should not contain any of ll, ii, dj, jw or ws, since these
    # codes will end up representing optimizations to be supported for the
    # request.
    set req.http.default_ps_capability_list_for_large_screens = "LargeScreen.SkipUADependentOptimizations:";
    set req.http.default_ps_capability_list_for_small_screens = "TinyScreen.SkipUADependentOptimizations:";

    # As a fallback, the PS-CapabilityList header that is sent to the upstream
    # PageSpeed server should be for a large screen device with no browser
    # specific optimizations.
    set req.http.PS-CapabilityList = req.http.default_ps_capability_list_for_large_screens;

    # Cache-fragment 1: Desktop User-Agents that support lazyload_images (ll),
    # inline_images (ii) and defer_javascript (dj).
    # Note: Wget is added for testing purposes only.
    if (req.http.User-Agent ~ "(?i)Chrome/|Firefox/|MSIE |Safari|Wget") {
      set req.http.PS-CapabilityList = "ll,ii,dj:";
    }
    # Cache-fragment 2: Desktop User-Agents that support lazyload_images (ll),
    # inline_images (ii), defer_javascript (dj), webp (jw) and lossless_webp
    # (ws).
    if (req.http.User-Agent ~
        "(?i)Chrome/[2][3-9]+\.|Chrome/[[3-9][0-9]+\.|Chrome/[0-9]{3,}\.") {
      set req.http.PS-CapabilityList = "ll,ii,dj,jw,ws:";
    }
    # Cache-fragment 3: This fragment contains (a) Desktop User-Agents that
    # should not map to fragments 1 or 2 and (b) all tablet User-Agents. These
    # will only get optimizations that work on all browsers and use image
    # compression qualities applicable to large screens. Note that even tablets
    # that are capable of supporting inline or webp images, for e.g. Android
    # 4.1.2, will not get these advanced optimizations.
    if (req.http.User-Agent ~ "(?i)Firefox/[1-2]\.|MSIE [5-8]\.|bot|Yahoo!|Ruby|RPT-HTTPClient|(Google \(\+https\:\/\/developers\.google\.com\/\+\/web\/snippet\/\))|Android|iPad|TouchPad|Silk-Accelerated|Kindle Fire") {
      set req.http.PS-CapabilityList = req.http.default_ps_capability_list_for_large_screens;
    }
    # Cache-fragment 4: Mobiles and small screen tablets will use image compression
    # qualities applicable to small screens, but all other optimizations will be
    # those that work on all browsers.
    if (req.http.User-Agent ~ "(?i)Mozilla.*Android.*Mobile*|iPhone|BlackBerry|Opera Mobi|Opera Mini|SymbianOS|UP.Browser|J-PHONE|Profile/MIDP|portalmmm|DoCoMo|Obigo|Galaxy Nexus|GT-I9300|GT-N7100|HTC One|Nexus [4|7|S]|Xoom|XT907") {
      set req.http.PS-CapabilityList = req.http.default_ps_capability_list_for_small_screens;
    }
    # Remove placeholder header values.
    remove req.http.default_ps_capability_list_for_large_screens;
    remove req.http.default_ps_capability_list_for_small_screens;
}

sub vcl_hash {
  # Block 3: Use the PS-CapabilityList value for computing the hash.
  hash_data(req.http.PS-CapabilityList);
}

# Block 3a: Define ACL for purge requests
acl purge {
  # Purge requests are only allowed from localhost.
  "localhost";
  "127.0.0.1";
}

# Block 3b: Issue purge when there is a cache hit for the purge request.
sub vcl_hit {
  if (req.request == "PURGE") {
    purge;
    set req.request = "GET";
    set req.http.X-purger = "Purged";
    error 800 "restart";
  } else {
    # Send 5% of the HITs to the backend for instrumentation.
    if (std.random(0, 100) <= 5) {
      set req.http.PS-ShouldBeacon = "${SECRET_KEY}";
      return (pass);
    }
  }
}

# Block 3c: Issue a no-op purge when there is a cache miss for the purge
# request.
sub vcl_miss {
  if (req.request == "PURGE") {
     purge;
     set req.request = "GET";
     set req.http.X-purger = "Purged-possibly";
     error 800 "restart";    # cant restart in miss, yet. go via error
  } else {
    # Send 25% of the MISSes to the backend for instrumentation.
    if (std.random(0, 100) <= 25) {
      set req.http.PS-ShouldBeacon = "${SECRET_KEY}";
      return (pass);
    }
  }
}

sub vcl_error {
  if (obj.status == 800 ) {
    return(restart);
  }
}

sub vcl_pass {
  if (req.request == "PURGE") {
    error 502 "PURGE on a passed object";
  }
}

# Block 4: In vcl_recv, on receiving a request, call the method responsible for
# generating the User-Agent based key for hashing into the cache.
sub vcl_recv {
 if (req.restarts == 0) {
     unset req.http.X-purger;
  }

  if (req.http.Cookie) {
    set req.http.Cookie = ";" + req.http.Cookie;
    set req.http.Cookie = regsuball(req.http.Cookie, "; +", ";");
    set req.http.Cookie = regsuball(req.http.Cookie, ";(${COOKIES:-NOCOOKIE})=", "; \1=");
    set req.http.Cookie = regsuball(req.http.Cookie, ";[^ ][^;]*", "");
    set req.http.Cookie = regsuball(req.http.Cookie, "^[; ]+|[; ]+$", "");

    if (req.http.Cookie == "") {
        remove req.http.Cookie;
    }
  }

  call generate_user_agent_based_key;

  # We want to support beaconing filters, i.e., one or more of inline_images,
  # lazyload_images, inline_preview_images or prioritize_critical_css are
  # enabled. We define a placeholder constant called ps_should_beacon_key_value
  # so that some percentages of hits and misses can be sent to the backend
  # with this value used for the PS-ShouldBeacon header to force beaconing.
  # This value should match the value of the DownstreamCacheRebeaconingKey
  # pagespeed directive used by your backend server.
  # WARNING: Do not use "random_rebeaconing_key" for your configuration, but
  # instead change it to something specific to your site, to keep it secure.
    
  # Incoming PS-ShouldBeacon headers should not be allowed since this will allow
  # external entities to force the server to instrument pages.
  remove req.http.PS-ShouldBeacon;

  # Block 3d: Verify the ACL for an incoming purge request and handle it.
  if (req.request == "PURGE") {
    if (!client.ip ~ purge) {
      error 405 "Not allowed.";
    }
    return (lookup);
  }
  # Blocks which decide whether cache should be bypassed or not go here.
  # Block 5a: Bypass the cache for .pagespeed. resource. PageSpeed has its own
  # cache for these, and these could bloat up the caching layer.
  # if (req.url ~ "\.pagespeed\.([a-z]\.)?[a-z]{2}\.[^.]{10}\.[^.]+") {
    # Skip the cache for .pagespeed. resource.  PageSpeed has its own
    # cache for these, and these could bloat up the caching layer.
    # return (pass);
  # }
  # Block 5b: Only cache responses to clients that support gzip.  Most clients
  # do, and the cache holds much more if it stores gzipped responses.
  # if (req.http.Accept-Encoding !~ "gzip") {
    # return (pass);
  # }
}

# Block 6: remove upstream cache control and varnish headers
sub vcl_fetch {
   if (beresp.http.Content-Type ~ "text/html") {
     # Hide the upstream cache control headers.
     remove beresp.http.ETag;
     remove beresp.http.Last-Modified;
     remove beresp.http.Cache-Control;
     remove beresp.http.X-Cache;
     remove beresp.http.X-Age;
     remove beresp.http.X-Varnish-Cache;
     remove beresp.http.X-Varnish-Cache-Hits;
     remove beresp.http.X-Varnish;
     
     set beresp.http.Cache-Control = "no-cache, max-age=0";
   }
   return (deliver);
}

# Block 7: Add a header for identifying cache hits/misses.
sub vcl_deliver {
  set resp.http.PS-CapabilityList = req.http.PS-CapabilityList;
  set resp.http.X-Page-Speed-Age = resp.http.Age;
  if (req.http.X-purger) {
    set resp.http.X-purger = req.http.X-purger;
  }
  if (obj.hits > 0) {
    set resp.http.X-Page-Speed-Cache = "HIT";
    # add a configurable extension to the ttl for other caches
    set resp.http.Cache-Control="public, max-age: ${MAX_AGE:-300}";
  } else {
    set resp.http.X-Page-Speed-Cache = "MISS";
  }
}